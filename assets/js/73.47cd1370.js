(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{432:function(t,v,_){"use strict";_.r(v);var e=_(42),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),_("h2",{attrs:{id:"http-1-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[t._v("#")]),t._v(" http/1.0")]),t._v(" "),_("p",[t._v("正式作为标准，传输内容格式不限制，增加了PUT、PATCH、HEAD、OPTIONS、DELETE 命令")]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"http-1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" http/1.1")]),t._v(" "),_("ul",[_("li",[t._v("持久连接（Keep-Alive）")]),t._v(" "),_("li",[t._v("管道机制")])]),t._v(" "),_("h3",{attrs:{id:"持久连接（keep-alive）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#持久连接（keep-alive）"}},[t._v("#")]),t._v(" 持久连接（Keep-Alive）")]),t._v(" "),_("blockquote",[_("p",[_("code",[t._v("http/1.0")]),t._v(" 客户端增加 "),_("code",[t._v("Connection: Keep-Alive")]),t._v(" 头部，服务器响应返回相同的头部，没有则不持久连接\n"),_("code",[t._v("http/2.0")]),t._v(" 客户端不用增加头部，只需要服务器响应返回 "),_("code",[t._v("Connection: Keep-Alive")]),t._v(" 头部")])]),t._v(" "),_("p",[t._v("在没有Keep-Alive之前，http请求都是短连接，就是说每一次请求都要建立连接，请求完成后马上关闭连接。每次请求都要建立连接带来了资源的浪费，为了提高请求效率，于是有了Keep-Alice。\nKeep—Alive允许在一定时间内，同一个域名多次请求数据，只建立一次http连接，其他请求可以复用这个连接通道，以达到提高请求效率的目的。")]),t._v(" "),_("h3",{attrs:{id:"管道机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#管道机制"}},[t._v("#")]),t._v(" 管道机制")]),t._v(" "),_("p",[t._v("浏览器要向一个域名发送多个请求，需要在本地维护一个FIFO队列，完成了一个再发送下一个，这样就存在一个问题，服务端从完成一个请求开始回传，到收到下一个请求的这段时间内是处于空闲状态的。\n将浏览器的请求一股脑的打包发给服务器，服务器就可以在出开完一个请求后，马上处理下一个，不会在之前说的空闲时间。")]),t._v(" "),_("p",[t._v("存在的问题：")]),t._v(" "),_("ul",[_("li",[t._v("队首阻塞")]),t._v(" "),_("li",[t._v("为了保证按顺序回传，缓存多个响应，占用资源")]),t._v(" "),_("li",[t._v("网络异常导致连接断开，无法得知服务器情况，全部重试导致重复处理")]),t._v(" "),_("li",[t._v("中间的代理设备不一定支持http管道")])]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"http-2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[t._v("#")]),t._v(" http/2.0")]),t._v(" "),_("ul",[_("li",[t._v("多路复用")]),t._v(" "),_("li",[t._v("服务端推送")]),t._v(" "),_("li",[t._v("头部️压缩")]),t._v(" "),_("li",[t._v("二进制帧数据传输")])]),t._v(" "),_("h3",{attrs:{id:"多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),_("p",[t._v("浏览器同一域名6个通道的限制，为了解决串行传输和连接数过多，通过"),_("code",[t._v("帧")]),t._v("对数据进行顺序标识，一个连接"),_("code",[t._v("并行")]),t._v("传输数据，最后按照"),_("code",[t._v("序列")]),t._v("对数据进行"),_("code",[t._v("合并")]),t._v("。\nHTTP/2对同一域名下所有请求都是基于"),_("code",[t._v("流")]),t._v("，同一域名不管访问多少文件，也只建立一路连接")]),t._v(" "),_("h3",{attrs:{id:"服务器推送"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送"}},[t._v("#")]),t._v(" 服务器推送")]),t._v(" "),_("p",[t._v("服务端可以主动推送，客户端也有权选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 "),_("code",[t._v("RST_STREAM帧")]),t._v(" 来拒收")]),t._v(" "),_("h3",{attrs:{id:"头部️压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#头部️压缩"}},[t._v("#")]),t._v(" 头部️压缩")]),t._v(" "),_("blockquote",[_("p",[t._v("头部压缩使用了HPACK算法，支持基于静态哈夫曼码表的哈夫曼编码")])]),t._v(" "),_("p",[t._v("http请求都是由状态行、请求/响应头部、消息主体三部分组成。\n静态字典：对头部常见键值对维护字典，减少字符。\n动态字典：维护一份相同的动态字典，可以动态的添加内容。")]),t._v(" "),_("h3",{attrs:{id:"二进制帧数据传输"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二进制帧数据传输"}},[t._v("#")]),t._v(" 二进制帧数据传输")]),t._v(" "),_("ul",[_("li",[t._v("帧\nhttp/2数据通信的最小单位。每个帧都包含帧首部，其中会标识当前帧所属的流。")]),t._v(" "),_("li",[t._v("消息\n指http/2中逻辑上的http消息。例如请求和响应等，"),_("code",[t._v("消息")]),t._v("由一个或多个"),_("code",[t._v("帧")]),t._v("组成。")]),t._v(" "),_("li",[t._v("流\n存在于连接中的虚拟通道。流可以承接双向消息，每个流都有一个唯一的整数id，HTTP/2对同一域名下所有请求都是基于"),_("code",[t._v("流")]),t._v("。")])]),t._v(" "),_("p",[t._v("http/2将请求和响应数据分隔成为更小的帧，并对他们采用二进制编码。\n同域名下的所有请求都在一个连接上完成，这个连接可以承载任意数量的"),_("code",[t._v("双向数据流")]),t._v("。\n每个数据"),_("code",[t._v("流")]),t._v("都以"),_("code",[t._v("消息")]),t._v("的形式发送，消息由一个或多个"),_("code",[t._v("帧")]),t._v("组成。多个帧之间可以乱序发送，然后根据帧首部的流标识可以重新组装。")])])}),[],!1,null,null,null);v.default=a.exports}}]);