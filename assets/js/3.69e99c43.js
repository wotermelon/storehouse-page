(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{354:function(v,_,t){v.exports=t.p+"assets/img/render.975fcbf7.png"},355:function(v,_,t){v.exports=t.p+"assets/img/render-1.b3ed5652.png"},356:function(v,_,t){v.exports=t.p+"assets/img/render-2.3c1b7310.png"},357:function(v,_,t){v.exports=t.p+"assets/img/render-3.7641c75a.png"},422:function(v,_,t){"use strict";t.r(_);var l=t(42),a=Object(l.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"渲染流程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程"}},[v._v("#")]),v._v(" 渲染流程")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("1.构建Dom树")]),v._v(" "),l("p",[v._v("构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出"),l("code",[v._v("树状结构")]),v._v("的 DOM")])]),v._v(" "),l("li",[l("p",[v._v("2.样式计算")]),v._v(" "),l("p",[v._v("当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。\n计算出 DOM 树中每个节点的具体样式，涉及到 CSS 的"),l("code",[v._v("继承规则")]),v._v("和"),l("code",[v._v("层叠规则")])])]),v._v(" "),l("li",[l("p",[v._v("3.布局阶段")]),v._v(" "),l("p",[v._v("计算出 DOM 树中"),l("code",[v._v("可见元素")]),v._v("的几何位置")]),v._v(" "),l("ul",[l("li",[v._v("遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；")]),v._v(" "),l("li",[v._v("而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，还有包含 "),l("code",[v._v("dispaly:none")]),v._v("之类的样式的元素也没有被包进布局树。")])])]),v._v(" "),l("li",[l("p",[v._v("4.图层分层")]),v._v(" "),l("p",[v._v("渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树")]),v._v(" "),l("ul",[l("li",[v._v("拥有"),l("code",[v._v("层叠上下文")]),v._v("属性的元素会被提升为单独的一层")]),v._v(" "),l("li",[v._v("需要"),l("code",[v._v("剪裁（clip）")]),v._v("的地方也会被创建为图层（如文字溢出）")]),v._v(" "),l("li",[v._v("出现滚动条，"),l("code",[v._v("滚动条")]),v._v("也会被提升为单独的层")])])]),v._v(" "),l("li",[l("p",[v._v("5.图层绘制")]),v._v(" "),l("p",[v._v("在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，生成图层的"),l("code",[v._v("绘制列表")])])]),v._v(" "),l("li",[l("p",[v._v("6.分块")]),v._v(" "),l("p",[l("code",[v._v("主线程")]),v._v("会把该绘制列表提交（commit）给"),l("code",[v._v("合成线程")]),v._v("，合成线程会将图层划分为图块")])]),v._v(" "),l("li",[l("p",[v._v("7.光栅化")]),v._v(" "),l("p",[v._v("合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图\n"),l("code",[v._v("图块")]),v._v("是栅格化执行的最小单位\n栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫"),l("code",[v._v("快速栅格化")])])]),v._v(" "),l("li",[l("p",[v._v("8.合成")]),v._v(" "),l("p",[v._v("一旦所有图块都被光栅化，"),l("code",[v._v("合成线程")]),v._v("就会生成一个绘制图块的命令，然后将该命令提交给"),l("code",[v._v("浏览器进程")])])])]),v._v(" "),l("p",[l("img",{attrs:{src:t(354),alt:"渲染流程"}})]),v._v(" "),l("p",[v._v("一个完整的渲染流程大致可总结为如下：")]),v._v(" "),l("ul",[l("li",[l("ol",[l("li",[v._v("渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。")])])]),v._v(" "),l("li",[l("ol",{attrs:{start:"2"}},[l("li",[v._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。")])])]),v._v(" "),l("li",[l("ol",{attrs:{start:"3"}},[l("li",[v._v("创建布局树，并计算元素的布局信息。")])])]),v._v(" "),l("li",[l("ol",{attrs:{start:"4"}},[l("li",[v._v("对布局树进行分层，并生成分层树。")])])]),v._v(" "),l("li",[l("ol",{attrs:{start:"5"}},[l("li",[v._v("为每个图层生成绘制列表，并将其提交到合成线程。")])])]),v._v(" "),l("li",[l("ol",{attrs:{start:"6"}},[l("li",[v._v("合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。")])])]),v._v(" "),l("li",[l("ol",{attrs:{start:"7"}},[l("li",[v._v("合成线程发送绘制图块命令 DrawQuad 给浏览器进程。")])])]),v._v(" "),l("li",[l("ol",{attrs:{start:"8"}},[l("li",[v._v("浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。")])])])]),v._v(" "),l("h2",{attrs:{id:"重排、重绘"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#重排、重绘"}},[v._v("#")]),v._v(" 重排、重绘")]),v._v(" "),l("ol",[l("li",[v._v("重排")])]),v._v(" "),l("blockquote",[l("p",[v._v("更新了元素的几何属性")])]),v._v(" "),l("p",[v._v("通过 JavaScript 或者 CSS 修改元素的"),l("code",[v._v("几何位置属性")]),v._v("，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排需要更新完整的渲染流水线，所以开销也是最大的")]),v._v(" "),l("p",[l("img",{attrs:{src:t(355),alt:"重排"}})]),v._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[v._v("重绘")])]),v._v(" "),l("blockquote",[l("p",[v._v("更新元素的绘制属性")])]),v._v(" "),l("p",[v._v("重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。")]),v._v(" "),l("p",[l("img",{attrs:{src:t(356),alt:"重绘"}})]),v._v(" "),l("h3",{attrs:{id:"问题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[v._v("#")]),v._v(" 问题")]),v._v(" "),l("ol",[l("li",[v._v("css是否会阻塞Dom树，还有js？")])]),v._v(" "),l("ul",[l("li",[v._v("DOM 树和 CSSOM 树是并行生成的，两个都完成后才进行布局树的生成。")]),v._v(" "),l("li",[v._v("如果期间有JS文件，需要等待JS文件加载并执行完成，JS也需要等待 CSSOM 树生成，JavaScript 脚本是"),l("code",[v._v("依赖样式表")]),v._v("的，多了一个阻塞过程，因为JS可能操作 DOM 树和 CSSOM 树。")]),v._v(" "),l("li",[v._v("不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。")])]),v._v(" "),l("p",[l("img",{attrs:{src:t(357),alt:""}})]),v._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[v._v("减少重排重绘的方法")])]),v._v(" "),l("ul",[l("li",[v._v("使用 class 操作样式，而不是频繁操作 style")]),v._v(" "),l("li",[v._v("避免使用 table 布局")]),v._v(" "),l("li",[v._v("批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React")]),v._v(" "),l("li",[v._v("Debounce window resize 事件")]),v._v(" "),l("li",[v._v("对 dom 属性的读写要分离")]),v._v(" "),l("li",[v._v("will-change: transform 做优化")])]),v._v(" "),l("ol",{attrs:{start:"3"}},[l("li",[v._v("async 和 defer 什么区别？")])]),v._v(" "),l("p",[v._v("async 脚本文件一旦加载完成，会"),l("code",[v._v("立即")]),v._v("执行。\ndefer 脚本文件，需要在 "),l("code",[v._v("DOMContentLoaded")]),v._v(" 事件之前执行")]),v._v(" "),l("ol",{attrs:{start:"4"}},[l("li",[v._v("如何缩短白屏时长？")])]),v._v(" "),l("ul",[l("li",[v._v("通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。")]),v._v(" "),l("li",[v._v("并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。")]),v._v(" "),l("li",[v._v("可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer")]),v._v(" "),l("li",[v._v("对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。")])]),v._v(" "),l("ol",{attrs:{start:"5"}},[l("li",[v._v("为什么主线程卡住了，css 动画依然可以执行")])]),v._v(" "),l("p",[v._v("重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时。\n合成操作是在合成线程上完成的，在执行合成操作时，是不会影响到主线程执行的。")])])}),[],!1,null,null,null);_.default=a.exports}}]);